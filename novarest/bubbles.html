<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Scene with Bubbles</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #displayText {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 24px;
            color: white;
            z-index: 1;
            text-shadow: 2px 2px 4px #000000;
        }
    </style>
</head>
<body>
    <div id="displayText"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>

    <script>
        let scene, camera, renderer, model, composer;
        let bubbles = [];

        function getUrlParameter(name) {
            name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
            var regex = new RegExp('[\\?&]' + name + '=([^&#]*)');
            var results = regex.exec(location.search);
            return results === null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));
        }

        function init() {
            // Get colors from URL parameters
            let brainColorHex = getUrlParameter('brain_color') || '0xc88d94';
            let bubbleColorHex = getUrlParameter('bubble_color') || '0x99ccff';
            let bgColorHex = getUrlParameter('bg_color') || '0x000000';

            // Convert hex colors to THREE.Color objects
            let brainColor = new THREE.Color(parseInt(brainColorHex, 16));
            let bubbleColor = new THREE.Color(parseInt(bubbleColorHex, 16));
            let backgroundColor = new THREE.Color(parseInt(bgColorHex, 16));

            // Set up the scene
            scene = new THREE.Scene();
            scene.background = backgroundColor;
            scene.fog = new THREE.Fog(scene.background, 1, 15);

            // Set up the camera
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 5);

            // Set up the renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // Post-processing setup
            composer = new THREE.EffectComposer(renderer);
            const renderPass = new THREE.RenderPass(scene, camera);
            composer.addPass(renderPass);

            const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.2;
            bloomPass.strength = 1.5;
            bloomPass.radius = 0.5;
            composer.addPass(bloomPass);

            // Load the brain model
            const loader = new THREE.GLTFLoader();
            loader.load('brain.glb', function (gltf) {
                model = gltf.scene;
                model.position.set(2.0, 2.0, 0);
                model.scale.set(2.0, 2.0, 2.0);

                model.traverse(function (child) {
                    if (child.isMesh) {
                        child.material.color.copy(brainColor);
                    }
                });

                scene.add(model);
            });

            // Add lighting
            const hemisphereLight = new THREE.HemisphereLight(0xffffbb, 0x080820, 1);
            scene.add(hemisphereLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);

            // Create bubbles
            for (let i = 0; i < 500; i++) {
                const geometry = new THREE.SphereGeometry(Math.random() * 0.5 + 0.2, 32, 32);
                const material = new THREE.MeshBasicMaterial({
                    color: bubbleColor,
                    opacity: 0.8,
                    transparent: true
                });
                const bubble = new THREE.Mesh(geometry, material);

                bubble.position.set(
                    Math.random() * 50 - 25, // x
                    Math.random() * -50,      // y
                    Math.random() * 50 - 25   // z
                );

                bubble.speed = Math.random() * 0.05 + 0.01;
                scene.add(bubble);
                bubbles.push(bubble);
            }

            // Set up OrbitControls
            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.25;
            controls.screenSpacePanning = false;
            controls.maxPolarAngle = Math.PI / 2;

            // Handle window resize
            window.addEventListener('resize', onWindowResize, false);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            // Update bubble positions
            bubbles.forEach(bubble => {
                bubble.position.y += bubble.speed;
                if (bubble.position.y > 30) {
                    bubble.position.y = -30;
                    bubble.position.x = Math.random() * 50 - 25;
                    bubble.position.z = Math.random() * 50 - 25;
                }
            });

            if (model) {
                model.rotation.y += 0.01; // Rotate the brain model
            }

            composer.render();
        }

        init();
        animate();

        // Function to update colors dynamically
        window.updateColors = function(brainHex, bubbleHex, bgHex) {
            let brainColor = new THREE.Color(parseInt(brainHex, 16));
            let bubbleColor = new THREE.Color(parseInt(bubbleHex, 16));
            let backgroundColor = new THREE.Color(parseInt(bgHex, 16));

            scene.background = backgroundColor;  // Update background color

            if (model) {
                model.traverse(function (child) {
                    if (child.isMesh) {
                        child.material.color.copy(brainColor);  // Update brain color
                    }
                });
            }

            bubbles.forEach(bubble => {
                bubble.material.color.copy(bubbleColor);  // Update bubble color
            });
        };

        // JavaScript function to update the text above the scene
        window.displayTextAboveBubbles = function(inputString) {
            document.getElementById('displayText').innerText = inputString;
        };
    </script>
</body>
</html>
